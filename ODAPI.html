<!DOCTYPE html>
<html>
<head>
  <title>Leaflet Map with Temperature, Humidity, Rainfall, and Search Bar</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
      html, body {
      margin: 0;
      padding: 0;
      height: 100%; 
    }
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px;
      background-color: #f0f0f0;
      border-bottom: 1px solid #ccc;
    }
    #map-container {
      display: flex;
      flex-direction: column;
      flex: 1; 
      position: relative;
    }
    #map {
      flex:1;
    }
    #info-panel {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: white;
      border: 1px solid black;
      padding: 10px;
      z-index: 1000;
      font-family: Arial, sans-serif;
      font-size: 12px; 
      box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
      max-width: 350px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      border: 1px solid black;
      padding: 3px; /* Reduced padding */
      text-align: left;
      word-wrap: break-word;
    }
    th {
      background-color: #f0f0f0;
      width: 40%;
    }
    td {
      width: 60%;
    }
    .temperature-label {
      font-weight: bold;
      font-size: 12px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 2px 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
      text-align: center;
      white-space: nowrap;
    }
    .temperature-label.armts {
      color: red;
    }
    .temperature-label.meso {
      color: orange;
    }
    .temperature-label.rainfall { 
      color: cyan;
    }
    .label-line {
      display: block;
      white-space: nowrap;
    }
    .label-line.humidity {
      color: blue;
    }
    .label-line.rainfall { 
      color: blue;
    }
    #search-container {
      display: flex;
      align-items: center;
    }
    #search-box {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 14px;
    }
    #search-button {
      padding: 5px 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      background-color: #f0f0f0;
      cursor: pointer;
      font-size: 14px;
    }
    @media (max-width: 768px) {
      .header {
        flex-direction: column; 
      }
      #map {
           height: 600px;
      }
      #info-panel {
        top: auto;
        bottom: 10px;
        right: 10px;
        left: 10px;
        width: auto;
        max-width: 90%;
        font-size: 10px;
      }
      #search-container {
        width: 100%; 
        margin-top: 5px; 
        margin-bottom: 5px;
      }
      #search-box {
        width: 70%;
      }
      #summary-table-container {
        display: none;
      }
      #toggle-summary {
        margin-bottom: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
  <h1>氣象站資料</h1>
  <div id="search-container">
    <input type="text" id="search-box" placeholder="Search station...">
    <button id="search-button">Search</button>
  </div>
  <div id="map"></div>
  <div id="info-panel">
    <h3>綜整資料</h3>
    <button id="toggle-summary">Show/Hide</button>
    <div id="summary-table-container">
      <table>
        <tbody id="summary-table">
        </tbody>
      </table>
    </div>
</div>

<script>
  const map = L.map('map').setView([23.6, 121], 7);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '© OpenStreetMap contributors'
  }).addTo(map);

  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  const drawControl = new L.Control.Draw({
    draw: {
      polyline: {
        shapeOptions: {
          color: 'blue',
          weight: 4,
          opacity: 0.7
        },
        metric: true,
        feet: false,
        showLength: true,
        showMeasurements: true,
        tooltip: {
          start: 'Click to start measuring',
          cont: 'Click to continue measuring',
          end: 'Click last point to finish'
        }
      },
      polygon: {
        allowIntersection: false,
        drawError: {
          color: 'red',
          message: 'Cannot intersect polygons!'
        },
        shapeOptions: {
          color: 'green',
          weight: 4,
          opacity: 0.5
        },
        showArea: true,
        showMeasurements: true,
        metric: true,
        tooltip: {
          start: 'Click to start drawing shape',
          cont: 'Click to continue drawing shape',
          end: 'Click first point to close this shape'
        }
      },
      circle: {
        shapeOptions: {
          color: 'red',
          weight: 4,
          opacity: 0.5
        },
        showRadius: true,
        metric: true,
        feet: false,
        tooltip: {
          start: 'Click and drag to draw a circle',
        }
      },
      rectangle: false,
      marker: false,
      circlemarker: false
    },
    edit: {
      featureGroup: drawnItems,
      remove: true
    }
  });
  map.addControl(drawControl);

  map.on(L.Draw.Event.CREATED, function (event) {
    const layer = event.layer;
    if (layer instanceof L.Circle) {
      const center = layer.getLatLng();
      const radius = layer.getRadius();
      drawnItems.addLayer(layer);
      // Optional: Add a popup to the circle
      layer.bindPopup(`Center: ${center.toString()}, Radius: ${radius.toFixed(0)} meters`);
    } else {
      drawnItems.addLayer(layer);
    }
    if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
      const distance = layer.getDistance();
      layer.bindPopup(`Distance: ${distance.toFixed(2)} meters`).openPopup();
    } else if (layer instanceof L.Polygon) {
      const area = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
      const areaKm2 = area / 1000000;
      layer.bindPopup(`Area: ${areaKm2.toFixed(2)} km²`).openPopup(); 
    }
  });

  L.Polyline.prototype.getDistance = function() {
    let totalDistance = 0;
    for (let i = 0; i < this._latlngs.length - 1; i++) {
      totalDistance += this._latlngs[i].distanceTo(this._latlngs[i + 1]);
    }
    return totalDistance;
  };

  let armtsStations = [];
  let mesoStations = [];
  let rainfallStations = [];

  let armtsData = {};
  let mesoData = {};
  let rainfallData = {};

  const stationMarkers = {};

  async function fetchArmtsData() {
    try {
      const response = await fetch('https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0001-001?Authorization=rdec-key-123-45678-011121314&format=JSON');
      const data = await response.json();

      if (data.success === "true") {
        const stations = data.records.Station;

        let highestTemp = -Infinity;
        let lowestTemp = Infinity;
        let highestTempStations = [];
        let lowestTempStations = [];
        let highestHumidity = -Infinity;
        let lowestHumidity = Infinity;
        let highestHumidityStations = [];
        let lowestHumidityStations = [];
        let missingDataStations = [];
        let highestTempTime = "";
        let lowestTempTime = "";
        let highestHumidityTime = "";
        let lowestHumidityTime = "";
        let observationTime = "";

        stations.forEach(station => {
          const stationData = {
            StationName: station.StationName,
            StationId: station.StationId,
            ObsTime: station.ObsTime.DateTime,
            AirTemperature: parseFloat(station.WeatherElement.AirTemperature),
            RelativeHumidity: parseFloat(station.WeatherElement.RelativeHumidity),
            Latitude: parseFloat(station.GeoInfo.Coordinates[1].StationLatitude),
            Longitude: parseFloat(station.GeoInfo.Coordinates[1].StationLongitude),
            NowPrecipitation: null,  // Initialize to null
            Past1hrPrecipitation: null, // Initialize to null
            Source: 'ARMTS'  // Add a source identifier
          };

          armtsStations.push(stationData); // Add to the ARMTS station array


          if (stationData.AirTemperature === -99 || stationData.RelativeHumidity === -99) {
            missingDataStations.push(stationData.StationName);
          }

          if (stationData.AirTemperature !== -99) {
            if (stationData.AirTemperature > highestTemp) {
              highestTemp = stationData.AirTemperature;
              highestTempStations = [stationData.StationName];
              highestTempTime = stationData.ObsTime;
            } else if (stationData.AirTemperature === highestTemp) {
              highestTempStations.push(stationData.StationName);
            }

            if (stationData.AirTemperature < lowestTemp) {
              lowestTemp = stationData.AirTemperature;
              lowestTempStations = [stationData.StationName];
              lowestTempTime = stationData.ObsTime;
            } else if (stationData.AirTemperature === lowestTemp) {
              lowestTempStations.push(stationData.StationName);
            }
          }

          if(stationData.RelativeHumidity !== -99){
            if (stationData.RelativeHumidity > highestHumidity) {
              highestHumidity = stationData.RelativeHumidity;
              highestHumidityStations = [stationData.StationName];
              highestHumidityTime = stationData.ObsTime;
            } else if (stationData.RelativeHumidity === highestHumidity) {
              highestHumidityStations.push(stationData.StationName);
            }

            if (stationData.RelativeHumidity < lowestHumidity) {
              lowestHumidity = stationData.RelativeHumidity;
              lowestHumidityStations = [stationData.StationName];
              lowestHumidityTime = stationData.ObsTime;
            } else if (stationData.RelativeHumidity === lowestHumidity) {
              lowestHumidityStations.push(stationData.StationName);
            }
          }
          if (observationTime === "") {
            observationTime = stationData.ObsTime;
          }

            const initialLabelContent = `<span class="label-line">${stationData.StationName} (${stationData.StationId})</span>
                                        <span class="label-line">${stationData.AirTemperature} °C</span>
                                        <span class="label-line humidity">濕度: ${stationData.RelativeHumidity}%</span>`;

            const tempLabel = L.divIcon({
                className: 'temperature-label armts',
                html: initialLabelContent,
                iconSize: [120, 80],
                iconAnchor: [60, 40]
            });

            const marker = L.marker([stationData.Latitude, stationData.Longitude], { icon: tempLabel });
            marker.addTo(map);

            stationMarkers[stationData.StationId] = marker;
        });

        if (lowestTemp === Infinity) {
          lowestTemp = "N/A";
          lowestTempStations = ["N/A"];
        }

        if (highestHumidity === -Infinity) {
          highestHumidity = "N/A";
          highestHumidityStations = ["N/A"];
          highestHumidityTime = "N/A";
        }

        if (lowestHumidity === Infinity) {
          lowestHumidity = "N/A";
          lowestHumidityStations = ["N/A"];
          lowestHumidityTime = "N/A";
        }

        armtsData = {
          stationCount: stations.length,
          highestTemp: highestTemp === -Infinity ? "N/A" : highestTemp,
          highestTempStations,
          lowestTemp: lowestTemp,
          lowestTempStations,
          highestTempTime: highestTempTime,
          lowestTempTime: lowestTempTime,
          highestHumidity: highestHumidity,
          highestHumidityStations,
          lowestHumidity: lowestHumidity,
          lowestHumidityStations,
          highestHumidityTime: highestHumidityTime,
          lowestHumidityTime: lowestHumidityTime,
          missingDataStations: missingDataStations.length === 0 ? "N/A" : missingDataStations.join(", "),
          observationTime
        };

      } else {
        console.error("ARMTS API response failed:", data);
      }
    } catch (error) {
      console.error("Error fetching ARMTS data:", error);
    }
  }

  async function fetchMesoData() {
    try {
      const response = await fetch('https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0003-001?Authorization=rdec-key-123-45678-011121314&format=JSON');
      const data = await response.json();

      if (data.success === "true") {
        const stations = data.records.Station;

        let highestTemp = -Infinity;
        let lowestTemp = Infinity;
        let highestTempStations = [];
        let lowestTempStations = [];
        let highestHumidity = -Infinity;
        let lowestHumidity = Infinity;
        let highestHumidityStations = [];
        let lowestHumidityStations = [];
        let missingDataStations = [];
        let highestTempTime = "";
        let lowestTempTime = "";
        let highestHumidityTime = "";
        let lowestHumidityTime = "";
        let observationTime = "";

        stations.forEach(station => {
          const stationData = {
            StationName: station.StationName,
            StationId: station.StationId,
            ObsTime: station.ObsTime.DateTime,
            AirTemperature: parseFloat(station.WeatherElement.AirTemperature),
            RelativeHumidity: parseFloat(station.WeatherElement.RelativeHumidity),
            Latitude: parseFloat(station.GeoInfo.Coordinates[0].StationLatitude), 
            Longitude: parseFloat(station.GeoInfo.Coordinates[0].StationLongitude),
            NowPrecipitation: null,  
            Past1hrPrecipitation: null, 
            Source: 'MESO' 
          };

          mesoStations.push(stationData); 

          if (stationData.AirTemperature === -99 || stationData.RelativeHumidity === -99) {
            missingDataStations.push(stationData.StationName);
          }

          if (stationData.AirTemperature !== -99) {
            if (stationData.AirTemperature > highestTemp) {
              highestTemp = stationData.AirTemperature;
              highestTempStations = [stationData.StationName];
              highestTempTime = stationData.ObsTime;
            } else if (stationData.AirTemperature === highestTemp) {
              highestTempStations.push(stationData.StationName);
            }

            if (stationData.AirTemperature < lowestTemp) {
              lowestTemp = stationData.AirTemperature;
              lowestTempStations = [stationData.StationName];
              lowestTempTime = stationData.ObsTime;
            } else if (stationData.AirTemperature === lowestTemp) {
              lowestTempStations.push(stationData.StationName);
            }
          }
          if(stationData.RelativeHumidity !== -99){
            if (stationData.RelativeHumidity > highestHumidity) {
              highestHumidity = stationData.RelativeHumidity;
              highestHumidityStations = [stationData.StationName];
              highestHumidityTime = stationData.ObsTime;
            } else if (stationData.RelativeHumidity === highestHumidity) {
              highestHumidityStations.push(stationData.StationName);
            }

            if (stationData.RelativeHumidity < lowestHumidity) {
              lowestHumidity = stationData.RelativeHumidity;
              lowestHumidityStations = [stationData.StationName];
              lowestHumidityTime = stationData.ObsTime;
            } else if (stationData.RelativeHumidity === lowestHumidity) {
              lowestHumidityStations.push(stationData.StationName);
            }
          }
           if (observationTime === "") {
            observationTime = stationData.ObsTime;
          }

          const initialLabelContent = `<span class="label-line">${stationData.StationName} (${stationData.StationId})</span>
                                      <span class="label-line">${stationData.AirTemperature} °C</span>
                                      <span class="label-line humidity">濕度: ${stationData.RelativeHumidity}%</span>`;

          const tempLabel = L.divIcon({
              className: 'temperature-label meso',
              html: initialLabelContent,
              iconSize: [120, 80], 
              iconAnchor: [60, 40]
          });

          const marker = L.marker([stationData.Latitude, stationData.Longitude], { icon: tempLabel });
          marker.addTo(map);

          stationMarkers[stationData.StationId] = marker;
        });

        if(lowestTemp === Infinity) {
          lowestTemp = "N/A";
          lowestTempStations = ["N/A"];
        }
        if (highestHumidity === -Infinity) {
          highestHumidity = "N/A";
          highestHumidityStations = ["N/A"];
          highestHumidityTime = "N/A";
        }

        if (lowestHumidity === Infinity) {
          lowestHumidity = "N/A";
          lowestHumidityStations = ["N/A"];
          lowestHumidityTime = "N/A";
        }

        mesoData = {
          stationCount: stations.length,
          highestTemp: highestTemp === -Infinity ? "N/A" : highestTemp,
          highestTempStations,
          lowestTemp: lowestTemp,
          lowestTempStations,
          highestTempTime: highestTempTime,
          lowestTempTime: lowestTempTime,
          highestHumidity: highestHumidity,
          highestHumidityStations,
          lowestHumidity: lowestHumidity,
          lowestHumidityStations,
          highestHumidityTime: highestHumidityTime,
          lowestHumidityTime: lowestHumidityTime,
          missingDataStations: missingDataStations.length === 0 ? "N/A" : missingDataStations.join(", "),
          observationTime
        };


      } else {
        console.error("MESO API response failed:", data);
      }
    } catch (error) {
      console.error("Error fetching MESO data:", error);
    }
  }

  // Fetch and process Rainfall data
  async function fetchRainfallData() {
    try {
      const response = await fetch('https://opendata.cwa.gov.tw/api/v1/rest/datastore/O-A0002-001?Authorization=rdec-key-123-45678-011121314&format=JSON');
      const data = await response.json();

      if (data.success === "true") {
        const stations = data.records.Station;

        let highestNowPrecipitation = -Infinity;
        let highestNowPrecipitationStations = [];
        let highestNowPrecipitationTime = "";
        let highestPast1hrPrecipitation = -Infinity;
        let highestPast1hrPrecipitationStations = [];
        let highestPast1hrPrecipitationTime = "";
        let missingDataStations = [];
        let observationTime = "";


        stations.forEach(station => {
          const stationData = {
            StationName: station.StationName,
            StationId: station.StationId,
            ObsTime: station.ObsTime.DateTime,
            Latitude: parseFloat(station.GeoInfo.Coordinates[1].StationLatitude),  // CORRECTED! Use index 1 for WGS84
            Longitude: parseFloat(station.GeoInfo.Coordinates[1].StationLongitude), // CORRECTED! Use index 1 for WGS84
            NowPrecipitation: parseFloat(station.RainfallElement.Now.Precipitation),
            Past1hrPrecipitation: parseFloat(station.RainfallElement.Past1hr.Precipitation),
            AirTemperature: null, 
            RelativeHumidity: null,
            Source: 'Rainfall' 
          };

            rainfallStations.push(stationData); 

            const armtsStation = armtsStations.find(s => s.StationId === stationData.StationId);
            if (armtsStation) {
              armtsStation.NowPrecipitation = stationData.NowPrecipitation;
              armtsStation.Past1hrPrecipitation = stationData.Past1hrPrecipitation;
            }

            // Check and update MESO stations with rainfall data
            const mesoStation = mesoStations.find(s => s.StationId === stationData.StationId);
            if (mesoStation) {
              mesoStation.NowPrecipitation = stationData.NowPrecipitation;
              mesoStation.Past1hrPrecipitation = stationData.Past1hrPrecipitation;
            }


          if (stationData.NowPrecipitation === -998 || stationData.NowPrecipitation === -999 || stationData.NowPrecipitation === null) {
            stationData.NowPrecipitation = 0;
          }
          if (stationData.Past1hrPrecipitation === -998 || stationData.Past1hrPrecipitation === -999 || stationData.Past1hrPrecipitation === null) {
            stationData.Past1hrPrecipitation = 0;
          }

          if (stationData.NowPrecipitation > highestNowPrecipitation) {
            highestNowPrecipitation = stationData.NowPrecipitation;
            highestNowPrecipitationStations = [stationData.StationName];
            highestNowPrecipitationTime = stationData.ObsTime;
          } else if (stationData.NowPrecipitation === highestNowPrecipitation) {
            highestNowPrecipitationStations.push(stationData.StationName);
          }

          if (stationData.Past1hrPrecipitation > highestPast1hrPrecipitation) {
            highestPast1hrPrecipitation = stationData.Past1hrPrecipitation;
            highestPast1hrPrecipitationStations = [stationData.StationName];
            highestPast1hrPrecipitationTime = stationData.ObsTime;
          } else if (stationData.Past1hrPrecipitation === highestPast1hrPrecipitation) {
            highestPast1hrPrecipitationStations.push(stationData.StationName);
          }

          if (observationTime === "") {
            observationTime = stationData.ObsTime;
          }
 
            if (!stationMarkers[stationData.StationId]) {  
                const rainfallLabel = L.divIcon({
                    className: 'temperature-label rainfall',
                    html: `<span class="label-line">${stationData.StationName} (${stationData.StationId})</span>
                           <span class="label-line rainfall">日累積雨量: ${stationData.NowPrecipitation} mm</span>
                           <span class="label-line rainfall">過去1小時雨量: ${stationData.Past1hrPrecipitation} mm</span>`,
                    iconSize: [120, 80], 
                    iconAnchor: [60, 40] 
                });
                const marker = L.marker([stationData.Latitude, stationData.Longitude], { icon: rainfallLabel }).addTo(map);
                stationMarkers[stationData.StationId] = marker;
            }


        });

        rainfallData = {
          stationCount: stations.length,
          highestNowPrecipitation: highestNowPrecipitation === -Infinity ? "N/A" : highestNowPrecipitation,
          highestNowPrecipitationStations,
          highestNowPrecipitationTime,
          highestPast1hrPrecipitation: highestPast1hrPrecipitation === -Infinity ? "N/A" : highestPast1hrPrecipitation,
          highestPast1hrPrecipitationStations,
          highestPast1hrPrecipitationTime,
          missingDataStations: missingDataStations.length === 0 ? "N/A" : missingDataStations.join(", "), //Probably not needed.
          observationTime
        };

      } else {
        console.error("Rainfall API response failed:", data);
      }
    } catch (error) {
      console.error("Error fetching Rainfall data:", error);
    }
  }
  function updateSummaryTable() {
    const table = document.getElementById('summary-table');
    table.innerHTML = ''; // Clear existing rows

    // Helper function to add rows
    function addRow(label, value, time = "") {
        const row = table.insertRow();
        const labelCell = row.insertCell(0);
        const valueCell = row.insertCell(1);
        const timeCell = row.insertCell(2);
        labelCell.textContent = label;
        valueCell.textContent = value;
        timeCell.textContent = time;  
    }


    addRow("ARMTS 測站數量", armtsData.stationCount || "N/A");
    addRow("MESO 測站數量", mesoData.stationCount || "N/A");
    addRow("雨量測站數量", rainfallData.stationCount || "N/A");
    addRow("最高溫度 (ARMTS)", `${armtsData.highestTemp} °C`, armtsData.highestTempTime);
    addRow("最高溫度測站 (ARMTS)", armtsData.highestTempStations ? armtsData.highestTempStations.join(", ") : "N/A");
    addRow("最低溫度 (ARMTS)", `${armtsData.lowestTemp} °C`, armtsData.lowestTempTime);
    addRow("最低溫度測站 (ARMTS)", armtsData.lowestTempStations ? armtsData.lowestTempStations.join(", ") : "N/A");
    addRow("最高濕度 (ARMTS)", `${armtsData.highestHumidity} %`, armtsData.highestHumidityTime);
    addRow("最高濕度測站 (ARMTS)", armtsData.highestHumidityStations ? armtsData.highestHumidityStations.join(", ") : "N/A");
    addRow("最低濕度 (ARMTS)", `${armtsData.lowestHumidity} %`, armtsData.lowestHumidityTime);
    addRow("最低濕度測站 (ARMTS)", armtsData.lowestHumidityStations ? armtsData.lowestHumidityStations.join(", ") : "N/A");
    addRow("資料缺失測站 (ARMTS)", armtsData.missingDataStations);
    addRow("最高溫度 (MESO)", `${mesoData.highestTemp} °C`, mesoData.highestTempTime);
    addRow("最高溫度測站 (MESO)", mesoData.highestTempStations ? mesoData.highestTempStations.join(", ") : "N/A");
    addRow("最低溫度 (MESO)", `${mesoData.lowestTemp} °C`, mesoData.lowestTempTime);
    addRow("最低溫度測站 (MESO)", mesoData.lowestTempStations ? mesoData.lowestTempStations.join(", ") : "N/A");
    addRow("最高濕度 (MESO)", `${mesoData.highestHumidity} %`, mesoData.highestHumidityTime);
    addRow("最高濕度測站 (MESO)", mesoData.highestHumidityStations ? mesoData.highestHumidityStations.join(", ") : "N/A");
    addRow("最低濕度 (MESO)", `${mesoData.lowestHumidity} %`, mesoData.lowestHumidityTime);
    addRow("最低濕度測站 (MESO)", mesoData.lowestHumidityStations ? mesoData.lowestHumidityStations.join(", ") : "N/A");
    addRow("資料缺失測站 (MESO)", mesoData.missingDataStations);
    addRow("最高日累積雨量", `${rainfallData.highestNowPrecipitation} mm`, rainfallData.highestNowPrecipitationTime);
    addRow("最高日累積雨量測站", rainfallData.highestNowPrecipitationStations ? rainfallData.highestNowPrecipitationStations.join(", ") : "N/A");
    addRow("最高過去1小時雨量", `${rainfallData.highestPast1hrPrecipitation} mm`, rainfallData.highestPast1hrPrecipitationTime);
    addRow("最高過去1小時雨量測站", rainfallData.highestPast1hrPrecipitationStations ? rainfallData.highestPast1hrPrecipitationStations.join(", ") : "N/A");
    addRow("資料缺失測站 (Rainfall)", rainfallData.missingDataStations);
    addRow("ARMTS 觀測時間", armtsData.observationTime);
    addRow("MESO 觀測時間", mesoData.observationTime);
    addRow("Rainfall 觀測時間", rainfallData.observationTime);

  }
  function updateArmtsRainfallLabels() {
      armtsStations.forEach(station => {
          const rainfallInfo = station.NowPrecipitation !== null ? `<span class="label-line rainfall">日累積雨量: ${station.NowPrecipitation} mm</span>` : '';
          const past1hrRainfallInfo = station.Past1hrPrecipitation !== null ? `<span class="label-line rainfall">過去1小時雨量: ${station.Past1hrPrecipitation} mm</span>` : '';
          const labelContent = `<span class="label-line">${station.StationName} (${station.StationId})</span>
                                <span class="label-line">${station.AirTemperature} °C</span>
                                <span class="label-line humidity">濕度: ${station.RelativeHumidity}%</span>
                                ${rainfallInfo}
                                ${past1hrRainfallInfo}`;

          const tempLabel = L.divIcon({
            className: 'temperature-label armts',
            html: labelContent,
            iconSize: [120, 80],  
            iconAnchor: [60, 40]  
          });

          const marker = stationMarkers[station.StationId];
          if (marker) { 
              marker.setIcon(tempLabel);
          }
      });
  }
  function updateMesoRainfallLabels() {
       mesoStations.forEach(station => {
          const rainfallInfo = station.NowPrecipitation !== null ? `<span class="label-line rainfall">日累積雨量: ${station.NowPrecipitation} mm</span>` : '';
          const past1hrRainfallInfo = station.Past1hrPrecipitation !== null ? `<span class="label-line rainfall">過去1小時雨量: ${station.Past1hrPrecipitation} mm</span>` : '';
          const labelContent = `<span class="label-line">${station.StationName} (${station.StationId})</span>
                                <span class="label-line">${station.AirTemperature} °C</span>
                                <span class="label-line humidity">濕度: ${station.RelativeHumidity}%</span>
                                ${rainfallInfo}
                                ${past1hrRainfallInfo}`;

           const tempLabel = L.divIcon({
            className: 'temperature-label meso',
            html: labelContent,
             iconSize: [120, 80],
             iconAnchor: [60, 40]
          });

          // Find and update the existing marker USING stationMarkers
          const marker = stationMarkers[station.StationId];
          if (marker) { // Check if the marker exists
              marker.setIcon(tempLabel);
          }
      });
  }

  function searchStation() {
    const searchTerm = document.getElementById('search-box').value.toLowerCase();
    let found = false;

    // Search in ARMTS stations
    for (const station of armtsStations) {
      if (station.StationName.toLowerCase().includes(searchTerm) || station.StationId.toLowerCase().includes(searchTerm)) {
        map.setView([station.Latitude, station.Longitude], 15);
        found = true;
        break; 
      }
    }

    if (!found) {
        for (const station of mesoStations) {
          if (station.StationName.toLowerCase().includes(searchTerm) || station.StationId.toLowerCase().includes(searchTerm)) {
            map.setView([station.Latitude, station.Longitude], 15);
            found = true;
            break;
          }
        }
    }

    //If not found in ARMTS, MESO, search in Rainfall stations
    if (!found) {
        for (const station of rainfallStations) {
          if (station.StationName.toLowerCase().includes(searchTerm) || station.StationId.toLowerCase().includes(searchTerm)) {
            map.setView([station.Latitude, station.Longitude], 15);
            found = true;
            break;
          }
        }
    }


    if (!found) {
      alert('Station not found!');
    }
  }

  document.getElementById('search-button').addEventListener('click', searchStation);
  //Event listener for Enter Key
  document.getElementById('search-box').addEventListener('keypress', function(event) {
      if (event.key === "Enter") {
          event.preventDefault(); 
          searchStation();
      }
  });

    function toggleSummary() {
      const summaryTableContainer = document.getElementById('summary-table-container');
      summaryTableContainer.style.display = summaryTableContainer.style.display === 'none' ? 'block' : 'none';
    }

    // Event listener for the toggle button
    document.getElementById('toggle-summary').addEventListener('click', toggleSummary);



  // Fetch data and initialize map
  async function initializeMap() {
    await fetchArmtsData();
    await fetchMesoData();
    await fetchRainfallData();
    updateSummaryTable();
    updateArmtsRainfallLabels(); 
    updateMesoRainfallLabels(); 
    toggleSummary(); 
  }

  initializeMap();
</script>
</body>
</html>
